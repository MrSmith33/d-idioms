<!DOCTYPE html>
<html><head><meta charset="utf-8">
<meta name="description" content="D Programming Language idioms.">
<style type="text/css"  media="all" >/* Eric Meyer's Reset CSS v2.0 - http://cssreset.com */
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}
html
{
    height: 100%;
    font-size: 10px;
}

body
{
    font-family: "HelveticaNeue", "Helvetica Neue", "HelveticaNeueRoman", "HelveticaNeue-Roman", "Helvetica Neue Roman", 'TeXGyreHerosRegular', "Helvetica", "Tahoma", "Geneva", "Arial", sans-serif;
    font-weight: 400;
    font-stretch: normal;
    display: block;
    color: #bbbbbb;
    background-color: #424040;
}

.container
{
    display: block;
    width: 90%;
    max-width: 1100px;
    padding: 0.5rem;
    margin: 0 auto;
    background-color: #bbbbbc;
    box-shadow: 0.2rem 0.4rem 1rem 0rem rgba(32,32,32,0.15);
}

.permalink
{
    float: right;
    display: inline-block;
    font-size: 0.7em;
}

header
{
    display: block;
    width: 90%;
    max-width: 1100px;
    font-size: 2.2rem;
    padding: 0.5rem;
    margin: 0 auto;
    height: 13rem;
    text-align: center;
    background-color: #744;
    font-weight: 700;
    line-height: 4em;
    vertical-align: middle;
    box-shadow: 0.2em 0.8em 1em 0em rgba(32,32,32,0.15);
    z-index: 5;
    color: #e8e8ef;
}
nav
{
    display: block;
    width: 90%;
    max-width: 1100px;
    font-size: 1.6rem;
    padding: 0.5rem;
    margin: 0 auto;
    background-color: #ededef;
    list-style-type: square;
    box-shadow: 0.2em 0.4em 2.0em 0em rgba(32,32,32,0.1);
    z-index: 10;
}

footer
{
    display: block;
    width: 90%;
    max-width: 1100px;
    font-size: 1.6rem;
    padding: 0.5rem;
    margin: 0 auto;
    background-color: #744;
    list-style-type: square;
    box-shadow: 0.2em 0.4em 2.0em 0em rgba(32,32,32,0.1);
    z-index: 10;
    color: black;
}


footer h2
{
    color: white;
    padding: 4rem 4.25rem 0rem 4.25rem;
    margin: 2rem;
}

footer p, footer ul
{
    padding: 0rem 4.25rem 0rem 4.25rem;
    margin: 2rem;
    color: white;
}

footer a
{
    color: #88f;
}

a
{
    text-decoration: none;
}

a
{
    color: #5050c0;
    font-weight: 700;
}

a:hover
{
    color: #5000c0;
}

nav a
{
    padding: 0.32em;
    margin: 1rem 8rem 1rem 8rem;
    display: list-item;

}

h1
{
    font-size: 2.38rem;
    padding: 1.2rem;
    margin: 0em 0em 2.4rem 1.2rem;
    color: #444;
}

h2
{
    font-size: 1.9rem;
    padding: 0.34rem;
    margin: 4rem 0rem 1rem -0.5rem;
    color: #444;
}

p
{
    padding: 1rem 2rem;
    padding: 1rem 2rem;
    max-width: 80rem;
}

ol
{
    margin: 0.85rem;
}

li
{
    display: list-item;
    list-style: square;
    margin: 0rem 0rem 0rem 6rem;
    padding: 0.34rem;
}

strong
{
    font-weight: 700;
}

em
{
    font-style:italic;
}

.prettyprint
{
    font-family: "Inconsolata", "Courier New", "Courier", monospace, sans-serif;
    color: #883900;
}

pre
{
    font-family: "Inconsolata", "Courier New", "Courier", monospace, sans-serif;
    padding: 0rem;
    margin: 1.7rem;
    font-size: 1.53rem;
    line-height: 1.7rem;
    box-shadow: inset 0.15rem 0.3rem 1.5rem 0rem rgba(0,0,0,0.2);
}
.idiom
{
    font-size: 1.7rem;
    color: #222;
    background-color: #ededef;
    display: block;
    padding: 8rem 6rem;
    margin: 2.4rem;
    line-height: 2.5rem;
    box-shadow: 0.17rem 0.34rem 1.7rem 0rem rgba(32,32,32,0.15);
}

#logo
{
    position: relative;
    left: -0.5rem;
    display: inline-block;
    vertical-align: middle;
    float: left;
}

#title
{
    display: inline-block;
    vertical-align: middle;
    float: left;
    text-align: center;
    margin: 2rem 2rem 2rem 4rem;
    font-size: 2.4rem;
}
/*
#contributors ul
{
    margin: 0rem 0rem 5rem 5rem;
    color: white;
}

#contributors li
{
    color: white;
}
*//*

vim-hybrid theme by w0ng (https://github.com/w0ng/vim-hybrid)

*/

/*background color*/
.hljs {
  display: block;
  overflow-x: auto;
  padding: 1.0em;
  background: #1d1f21;
  -webkit-text-size-adjust: none;
}

/*selection color*/
.hljs::selection,
.hljs span::selection {
	background: #bababa;
}
.hljs::-moz-selection,
.hljs span::-moz-selection {
	background: #bababa;
}

/*foreground color*/
.hljs,
.hljs-setting .hljs-value,
.hljs-expression .hljs-variable,
.hljs-expression .hljs-begin-block,
.hljs-expression .hljs-end-block,
.hljs-class .hljs-params,
.hljs-function .hljs-params,
.hljs-at_rule .hljs-preprocessor {
  color: #c5c8c6;
}

/*color: fg_yellow*/
.hljs-title,
.hljs-function .hljs-title,
.hljs-keyword .hljs-common,
.hljs-class .hljs-title,
.hljs-decorator,
.hljs-tag .hljs-title,
.hljs-header,
.hljs-sub,
.hljs-function {
  color: #f0c674;
}

/*color: fg_comment*/
.hljs-comment,
.hljs-javadoc,
.hljs-output .hljs-value,
.hljs-pi,
.hljs-shebang,
.hljs-doctype {
  color: #707880;
}

/*color: fg_red*/
.hljs-number,
.hljs-symbol,
.hljs-literal,
.hljs-deletion,
.hljs-link_url,
.hljs-symbol .hljs-string,
.hljs-argument,
.hljs-hexcolor,
.hljs-input .hljs-prompt,
.hljs-char {
 color: #cc6666
}

/*color: fg_green*/
.hljs-string,
.hljs-special,
.hljs-javadoctag,
.hljs-addition,
.hljs-important,
.hljs-tag .hljs-value,
.hljs-at.rule .hljs-keyword,
.hljs-regexp,
.hljs-attr_selector {
  color: #b5bd68;
}

/*color: fg_purple*/
.hljs-variable,
.hljs-property,
.hljs-envar,
.hljs-code,
.hljs-expression,
.hljs-localvars,
.hljs-id,
.hljs-variable .hljs-filter,
.hljs-variable .hljs-filter .hljs-keyword,
.hljs-template_tag .hljs-filter .hljs-keyword {
 color: #b294bb;
}

/*color: fg_blue*/
.hljs-statement,
.hljs-label,
.hljs-keyword,
.hljs-xmlDocTag,
.hljs-function .hljs-keyword,
.hljs-chunk,
.hljs-cdata,
.hljs-link_label,
.hljs-bullet,
.hljs-class .hljs-keyword,
.hljs-smartquote,
.hljs-method,
.hljs-list .hljs-title,
.hljs-tag {
 color: #81a2be;
}

/*color: fg_aqua*/
.hljs-pseudo,
.hljs-exception,
.hljs-annotation,
.hljs-subst,
.hljs-change,
.hljs-cbracket,
.hljs-operator,
.hljs-horizontal_rule,
.hljs-preprocessor .hljs-keyword,
.hljs-typedef,
.hljs-template_tag,
.hljs-variable,
.hljs-variable .hljs-filter .hljs-argument,
.hljs-at_rule,
.hljs-at_rule .hljs-string,
.hljs-at_rule .hljs-keyword {
  color: #8abeb7;
}


/*color: fg_orange*/
.hljs-type,
.hljs-typename,
.hljs-inheritance .hljs-parent,
.hljs-constant,
.hljs-built_in,
.hljs-setting,
.hljs-structure,
.hljs-link_reference,
.hljs-attribute,
.hljs-blockquote,
.hljs-quoted,
.hljs-class,
.hljs-header {
  color: #de935f;
}

.hljs-emphasis
{
  font-style: italic;
}

.hljs-strong
{
  font-weight: bold;
}




</style><link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
<title>d-idioms - Idioms for the D programming language</title></head><body><script src="highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<header><img id="logo" src="d-logo.svg"></img><div id="title">Idioms for the D Programming Language
</div></header><nav><a href="#&#x2F;+-+&#x2F;-nestable-comments-and-version(none)">&#x2F;+ +&#x2F; nestable comments and version(none)
</a><a href="#Adding-or-removing-an-element-from-arrays">Adding or removing an element from arrays
</a><a href="#assert(false)-is-special">assert(false) is special
</a><a href="#Bypassing-@nogc">Bypassing @nogc
</a><a href="#Capturing-with-regular-expressions">Capturing with regular expressions
</a><a href="#D-online-resources">D online resources
</a><a href="#Embed-a-dynamic-library-in-an-executable">Embed a dynamic library in an executable
</a><a href="#Ensure-array-access-without-bounds-checking">Ensure array access without bounds checking
</a><a href="#Enumerate-fields-with-__traits(allMembers)">Enumerate fields with __traits(allMembers)
</a><a href="#Extending-a-struct-with-alias-this">Extending a struct with alias this
</a><a href="#Falsey-values">Falsey values
</a><a href="#Getting-a-method-callbacked-from-C">Getting a method callbacked from C
</a><a href="#Grouping-modules-with-package.d">Grouping modules with package.d
</a><a href="#How-does-D-improve-on-C++17&#63;">How does D improve on C++17&#63;
</a><a href="#How-the-D-Garbage-Collector-works">How the D Garbage Collector works
</a><a href="#if-(__ctfe)">if (__ctfe)
</a><a href="#if-embedded-declaration">if embedded declaration
</a><a href="#Implicit-conversion-for-user-defined-types">Implicit conversion for user-defined types
</a><a href="#Inheriting-from-Exception">Inheriting from Exception
</a><a href="#Linking-with-C-gotchas">Linking with C gotchas
</a><a href="#Minimum-or-maximum-of-numbers">Minimum or maximum of numbers
</a><a href="#Never-use-&gt;=-for-dependencies">Never use &gt;= for dependencies
</a><a href="#Optimal-AA-lookup">Optimal AA lookup
</a><a href="#Patching-a-library-available-on-the-DUB-registry">Patching a library available on the DUB registry
</a><a href="#Phobos-gems">Phobos gems
</a><a href="#Placement-new-with-emplace">Placement new with emplace
</a><a href="#Porting-from-C-gotchas">Porting from C gotchas
</a><a href="#Qualified-switch-using-with">Qualified switch using with
</a><a href="#Recursive-Sum-Type-with-matching">Recursive Sum Type with matching
</a><a href="#Searching-for-a-substring-position">Searching for a substring position
</a><a href="#Should-I-use-++pre-increment-or-post-increment++&#x3F;">Should I use ++pre-increment or post-increment++&#x3F;
</a><a href="#Skip-initialization-with-=-void">Skip initialization with = void
</a><a href="#Slices-.capacity,-the-mysterious-property">Slices .capacity, the mysterious property
</a><a href="#Smallest-dub.json-for-an-executable">Smallest dub.json for an executable
</a><a href="#So-what-does--release-do,-exactly&#63;">So what does -release do, exactly&#63;
</a><a href="#Static-arrays-are-value-types">Static arrays are value types
</a><a href="#The-impossible-real-time-thread">The impossible real-time thread
</a><a href="#The-trouble-with-class-destructors">The trouble with class destructors
</a><a href="#The-truth-about-shared">The truth about shared
</a><a href="#Unrecoverable-vs-recoverable-errors">Unrecoverable vs recoverable errors
</a><a href="#Using-a-struct-to-simplify-format()">Using a struct to simplify format()
</a></nav><div class="container"><a name="&#x2F;+-+&#x2F;-nestable-comments-and-version(none)"></a><div class="idiom"><a class="permalink" href="#&#x2F;+-+&#x2F;-nestable-comments-and-version(none)">Link
</a><h1><code class="prettyprint">/+ +/</code> nestable comments and <code class="prettyprint">version(none)</code></h1>
<p>In addition to single-line comments <code class="prettyprint">//</code> and block comments <code class="prettyprint">/* */</code>, D supports nestable block comments with <code class="prettyprint">/+ +/</code>.
</p>
<pre class="prettyprint"><code>/+
    This whole block is commented.

    /**
     * A documented function.
     */
    void doStuff()
    {
        // blah blah
    }

    /+
      Such block comments are nestable.
    +/
+/

</code></pre><p>They are handy when commenting large swaths of code. It would be the D equivalent to <code class="prettyprint">#if 0</code> / <code class="prettyprint">#endif</code> pairs in C or C++.
</p>
<p>If you prefer the commented portion of code to stay valid, prefer using <code class="prettyprint">version(none)</code>.
</p>
<pre class="prettyprint"><code>version(none)
{
    // This whole block is commented, but still must parse.

    /**
     * A documented function
     */
    void doStuff()
    {
        // blah blah
    }
}

</code></pre><p>Indeed, <code class="prettyprint">none</code> is a special version identifier that cannot be set.
</p>
<pre class="prettyprint"><code>version = none; // Error: version identifier 'none' is reserved and cannot be set
</code></pre></div><a name="Adding-or-removing-an-element-from-arrays"></a><div class="idiom"><a class="permalink" href="#Adding-or-removing-an-element-from-arrays">Link
</a><h1>Adding or removing an element from arrays</h1>
<p>Appending an element to a dynamic array:
</p>
<pre class="prettyprint"><code>T[] arr;
arr ~= value;                    // value is pushed at the back of the array
</code></pre><p>Removing an element from a dynamic array given an index:
</p>
<pre class="prettyprint"><code>import std.algorithm : remove;
T[] arr;
arr = arr.remove(index);         // index-th element is removed from array
</code></pre><p>Removing an element from a dynamic array given a value:
</p>
<pre class="prettyprint"><code>auto removeElement(R, N)(R haystack, N needle)
{
    import std.algorithm : countUntil, remove;
    auto index = haystack.countUntil(needle);
    return (index != -1) ? haystack.remove(index) : haystack;
}
int[] arr = [1, 5, 10];
arr = arr.removeElement(5);
assert(arr == [1,10]);
</code></pre><p>Adding an element into an associative array:
</p>
<pre class="prettyprint"><code>aa[key] = value;                 // aa[key] is created if not already existing
</code></pre><p>Removing an element from an associative array given a key:
</p>
<pre class="prettyprint"><code>aa.remove(key);                  // there is a builtin property to do that
</code></pre></div><a name="assert(false)-is-special"></a><div class="idiom"><a class="permalink" href="#assert(false)-is-special">Link
</a><h1><code class="prettyprint">assert(false)</code> is special</h1>
<p><code class="prettyprint">assert(false)</code>, <code class="prettyprint">assert(0)</code>, <code class="prettyprint">assert(null)</code>…… or any other false expression at compile-time do not produce a regular <code class="prettyprint">assert</code>.
</p>
<p>Instead it is an instruction to crash the program and is <strong>not</strong> removed in <code class="prettyprint">-release</code> mode.
</p>
<pre class="prettyprint"><code>string getStuff()
{
    if(expr)
        return "something";
    assert(1 &lt; 0); // also possible, but "assert(0)" is typically used
    // no return needed, since we just crashed
}
</code></pre><p>An <code class="prettyprint">assert(false)</code> form also mean a branch of a function doesn't need to return something since the program will crash.
</p>
<p><strong>It does not mean </strong> <em>unreachable code</em><strong>, it means </strong> <em>crash now</em> <strong> and the compiler will never remove it.</strong>
</p>
</div><a name="Bypassing-@nogc"></a><div class="idiom"><a class="permalink" href="#Bypassing-@nogc">Link
</a><h1>Bypassing @nogc</h1>
<p><code class="prettyprint">@nogc</code> is a function attribute which ensures a function never allocates through the GC.
</p>
<pre class="prettyprint"><code>void processStuff(double[] data) @nogc
{
    double[] tempBuffer;

    // Error: setting 'length' in @nogc function processStuff may cause GC a
    tempBuffer.length = data.length; 

    ...
}
</code></pre><p>Using <code class="prettyprint">@nogc</code> is a must to have a memory-conscious code section or having real-time threads.
</p>
<p>However, not all library functions that could be marked <code class="prettyprint">@nogc</code> are. You'll probably want at one point to call functions as if they were <code class="prettyprint">@nogc</code>. Here is how to do it:
</p>
<pre class="prettyprint"><code>import std.traits;

// Casts @nogc out of a function or delegate type.
auto assumeNoGC(T) (T t) if (isFunctionPointer!T || isDelegate!T)
{
    enum attrs = functionAttributes!T | FunctionAttribute.nogc;
    return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;
}

// This function can't be marked @nogc but you know with application knowledge it won't use the GC.
void funcThatMightUseGC(int timeout)
{
    if (unlikelyCondition(timeout))
        throw new Exception("The world actually imploded.");

    doMoreStuff();
}

void funcThatCantAffortGC() @nogc
{
    // using a casted delegate literal to call non-@nogc code
    assumeNoGC( (int timeout)
                {
                    funcThatMightUseGC(timeout);
                })(10000);
}
</code></pre></div><a name="Capturing-with-regular-expressions"></a><div class="idiom"><a class="permalink" href="#Capturing-with-regular-expressions">Link
</a><h1>Capturing with regular expressions</h1>
<p>Regular expressions are found in the <code class="prettyprint">std.regex</code> Phobos module.
</p>
<pre class="prettyprint"><code>import std.regex;
import std.stdio;

void main(string args[])
{
    auto re = regex(`My name is (\w+)\. I work for ([A-Za-z ]+)\.`);

    string input = "My name is Kobayashi. I work for Keyser Soze.";

    if (auto captures = matchFirst(input, re))
    {
        // There is a trap there, capture[0] is the whole matched string
        writefln("First capture = %s", captures[1]);
        writefln("2nd capture   = %s", captures[2]);
    }
}
</code></pre><p><code class="prettyprint">ctRegex</code> instead of <code class="prettyprint">regex</code> builds the regular expression at compile-time, trading of compile-time speed for runtime speed.
</p>
<pre class="prettyprint"><code>auto re = ctRegex!(`My name is (\w+)\. I work for ([A-Za-z ]+)\.`); // automaton built at compile-time
</code></pre><p>See: <a href="http://dlang.org/phobos/std_regex.html">http://dlang.org/phobos/std_regex.html</a>
</p>
</div><a name="D-online-resources"></a><div class="idiom"><a class="permalink" href="#D-online-resources">Link
</a><h1>D online resources</h1>
<ul>
<li><a href="http://wiki.dlang.org/Books">List of available D books</a>
</li>
<li><a href="http://rosettacode.org/wiki/Category:D">D page on rosettacode.org</a>
</li>
<li><a href="http://dlang.org/phobos/index.html">Phobos documentation</a>
</li>
<li><a href="http://wiki.dlang.org/">The D wiki</a>
</li>
<li><a href="http://forum.dlang.org/">D newsgroup</a>
</li>
<li><a href="http://code.dlang.org/">DUB registry</a>
</li>
<li><a href="http://qznc.github.io/d-tut/index.html">Pragmatic D Tutorial</a>
</li>
<li><a href="https://github.com/PhilippeSigaud/D-templates-tutorial/raw/master/D-templates-tutorial.pdf">D template tutorial by Philippe Sigaud</a>
</li>
</ul>
</div><a name="Embed-a-dynamic-library-in-an-executable"></a><div class="idiom"><a class="permalink" href="#Embed-a-dynamic-library-in-an-executable">Link
</a><h1>Embed a dynamic library in an executable</h1>
<p>Let's say we want to distribute a stand-alone executable that doesn't need any installation.<br>Here we'll see how to embed SDL.dll into an executable.
</p>
<pre class="prettyprint"><code>import std.uuid;
import std.file;
import std.path;
import std.string;
ubyte[] sdlBytes = cast(ubyte[]) import("SDL2.dll");   // SDL2.dll contents
void main(string[] args)
{
    auto uuid = randomUUID();
    string uuid = randomUUID().toString();
    string filename = format("SDL2-%s.dll", uuid);     // Making an unique file name.
    string depacked = buildPath(tempDir(), filename);
    std.file.write(depacked, sdlBytes);                // Writing the dynlib to a temporary file.
    DerelictSDL2.load(depacked);                       // Use the depacked dynlib and load its symbols.
}
</code></pre><p>A similar trick can be done for embedding fonts, images, etc... without dealing with a resource compiler.
</p>
</div><a name="Ensure-array-access-without-bounds-checking"></a><div class="idiom"><a class="permalink" href="#Ensure-array-access-without-bounds-checking">Link
</a><h1>Ensure array access without bounds checking</h1>
<p>Slice indexing will check bounds depending on <code class="prettyprint">-boundscheck</code> and <code class="prettyprint">@safe</code>.
</p>
<p>But pointer indexing won't ever check bounds.
</p>
<pre class="prettyprint"><code>int[] myArray;
myArray.ptr[index] = 4; // no bounds check, guaranteed
</code></pre></div><a name="Enumerate-fields-with-__traits(allMembers)"></a><div class="idiom"><a class="permalink" href="#Enumerate-fields-with-__traits(allMembers)">Link
</a><h1>Enumerate fields with <code class="prettyprint">__traits(allMembers)</code></h1>
<p>Using <code class="prettyprint">__traits(allMembers, X)</code> allows to iterate on fields of a <code class="prettyprint">struct</code> or <code class="prettyprint">class</code> X.
</p>
<p>Some uses:
</p>
<ul>
<li>implement generic serialization/deserialization
</li>
<li>implement a generic comparison, <code class="prettyprint">.dup</code>, copy, &hellip; for any aggregate
</li>
<li>describe an OpenGL vertex format from the structure
</li>
</ul>
<p>Here is how <a href="https://github.com/D-Programming-Language/dub">DUB</a> implements a <code class="prettyprint">.dup</code> with <code class="prettyprint">__traits(allMembers)</code>:
</p>
<pre class="prettyprint"><code>BuildSettings dup() const
{
    BuildSettings ret;
    foreach (m; __traits(allMembers, BuildSettings)) // this foreach is a special "static" foreach
    {
        static if (is(typeof(__traits(getMember, ret, m) = __traits(getMember, this, m).dup)))
            __traits(getMember, ret, m) = __traits(getMember, this, m).dup;
        else static if (is(typeof(__traits(getMember, ret, m) = __traits(getMember, this, m))))
            __traits(getMember, ret, m) = __traits(getMember, this, m);
    }
    return ret;
}
</code></pre><p>Now if new members are added to BuildSettings, this generic <code class="prettyprint">.dup</code> will still duplicate them.
</p>
</div><a name="Extending-a-struct-with-alias-this"></a><div class="idiom"><a class="permalink" href="#Extending-a-struct-with-alias-this">Link
</a><h1>Extending a struct with alias this</h1>
<p>What if we want to decorate a struct with additional features?<br>We can't use virtual dispatch since the parent aggregate is a <code class="prettyprint">struct</code>.<br>That means we are on board for extensive manual delegation of method calls to a member.
</p>
<p>Fortunately the <code class="prettyprint">alias this</code> feature comes to the rescue!
</p>
<p>As an example, let's write a wrapper around the Phobos <code class="prettyprint">File</code> struct to write HTML page.
</p>
<pre class="prettyprint"><code>import std.stdio;
import std.file;
struct HTMLPage
{
    File file;
    alias file this; // file's methods are looked at on name lookup.
    this(string path)
    {
        file = File(path, "w"); // akin to calling parent constructor
    }
    void writeAnchor(string anchor)
    {
        writeln("&lt;" ~ anchor ~ "&gt;"); // will call file.writeln
    }
}
</code></pre><p>When using <code class="prettyprint">HTMLPage</code> you will still have access to every File method. For example, you'll be able to do:
</p>
<pre class="prettyprint"><code>htmlPage.writeln("&lt;doctype html&gt;");
</code></pre><p>This site uses this idiom.
</p>
<p><code class="prettyprint">alias this</code> also define an implicit conversion.
</p>
<pre class="prettyprint"><code>struct A
{
    int a;
}
struct B
{
    A a;
    alias a this;
    string b;
}
int f(A a)
{
    return a.a+1;
}
int g(ref A a)
{
    return a.a+1;
}
ref A h(ref A a)
{
    return a;
}
void main(string[]ags)
{
    B b;
    return f(b)  // b implicitely converted to an A
         + g(b); // b implicitely converted to a ref A
}
</code></pre><p>As <a href="http://www.amazon.fr/The-Programming-Language-Andrei-Alexandrescu/dp/0321635361">TDPL</a> says it, using <code class="prettyprint">alias this</code> is subtyping.
</p>
</div><a name="Falsey-values"></a><div class="idiom"><a class="permalink" href="#Falsey-values">Link
</a><h1>Falsey values</h1>
<p>In an <code class="prettyprint">if(expr)</code> condition, <code class="prettyprint">expr</code> does not need to have boolean type.
</p>
<p>Falsey value in D are:
</p>
<ul>
<li>the integer 0
</li>
<li>the floating point value +0.0 and -0.0
</li>
<li>the <code class="prettyprint">null</code> pointer / <code class="prettyprint">null</code> delegate / <code class="prettyprint">null</code> class reference
</li>
<li>the boolean <code class="prettyprint">false</code>
</li>
<li>enum members equal to 0
</li>
<li>slices containing a <code class="prettyprint">null</code> pointer, ie. when <code class="prettyprint">(slice is null)</code> returns <code class="prettyprint">true</code>
</li>
</ul>
<p>The empty string <code class="prettyprint">""</code> and the empty slice <code class="prettyprint">[]</code> are truthy.
</p>
</div><a name="Getting-a-method-callbacked-from-C"></a><div class="idiom"><a class="permalink" href="#Getting-a-method-callbacked-from-C">Link
</a><h1>Getting a method callbacked from C</h1>
<p>Most C callbacks allow to specify a "user data" pointer.<br>A common trick is to cast <code class="prettyprint">this</code> into a <code class="prettyprint">void*</code> pointer back and forth, and use it as user data.
</p>
<p>Here is an example with SDL2 logging handler:
</p>
<pre class="prettyprint"><code>class MyGame
{
    this()
    {
        // Pass this as user data, since most C callbacks have one.
        SDL_LogSetOutputFunction(&amp;loggingCallbackSDL, cast(void*)this);
    }

    // We'd like this method to get called whenever the SDL callback triggers
    void onMessage(const(char)* message)
    {
        // do stuff
    }
}

extern(C)  // would be extern(System) depending on the library
void loggingCallbackSDL(void* userData, int category, SDL_LogPriority priority, const(char)* message)
{
    // Get back the object reference here
    MyGame game = cast(MyGame)userData;
    game.onMessage(message);
}
</code></pre></div><a name="Grouping-modules-with-package.d"></a><div class="idiom"><a class="permalink" href="#Grouping-modules-with-package.d">Link
</a><h1>Grouping modules with package.d</h1>
<p><code class="prettyprint">package.d</code> is a special filename which is used in import resolution. When reading:
</p>
<pre class="prettyprint"><code>import mymodule;
</code></pre><p>a D compiler will search for either <code class="prettyprint">mymodule.d</code> or <code class="prettyprint">mymodule/package.d</code> (and if both exist, it will complain about the name conflict).
</p>
<p>This feature allows to organize modules logically and combined with <code class="prettyprint">public import</code> to split big modules in several parts.
</p>
<p>Here is an example:
</p>
<pre class="prettyprint"><code>// In file path/mypackage/package.d
module mypackage;
public import mypackage.foo;
public import mypackage.bar;
</code></pre><pre class="prettyprint"><code>// In file path/mypackage/foo.d
module mypackage.foo;
</code></pre><pre class="prettyprint"><code>// In file path/mypackage/bar.d
module mypackage.bar;
</code></pre><pre class="prettyprint"><code>// In user code
// mypackage.foo and mypackage.bar are also imported
import mypackage;
</code></pre></div><a name="How-does-D-improve-on-C++17&#63;"></a><div class="idiom"><a class="permalink" href="#How-does-D-improve-on-C++17&#63;">Link
</a><h1>How does D improve on C++17?</h1>
<p><strong>Warning: this article is opinionated.</strong>
</p>
<p>&nbsp;
</p>
<p>With C++ evolving and coming to C++17, <strong>is D still relevant?</strong>
</p>
<p>I think that yes, and very much so. Here's is why.
</p>
<h2> No more preprocessor</h2>
<p>D has no need for a preprocessor.
</p>
<h2> No more header files, today</h2>
<p>Even when C++ compilers implement modules and you can finally use them, headers will still survive alongside modules for backward compatibility.
</p>
<h2> No more order of declaration</h2>
<p>Order of declaration is insignificant in D. There is no need to pre-declare or reorder anything.
</p>
<h2> Faster compiles</h2>
<p>C++ has <a href="http://www.drdobbs.com/cpp/c-compilation-speed/228701711">compilation speed problems</a>. For example the preprocessor needs to iterate on source files at least 3 times by design.
</p>
<p>What happens in C++ shops is that programmers spend a significant amount of time waiting for the compiler.
</p>
<h2> Lexing stage separated from parsing stage separated from semantics</h2>
<p>No need for the semantic pass to separate the language in tokens.
</p>
<h2> Name conflict bugs are impossible</h2>
<p>A name conflict when importing modules with the same identifier triggers a compilation error. It is thus impossible to use the wrong symbol by mistake.
</p>
<h2> Default initialization</h2>
<p>Uninitialized variables can create subtle and hard to find bugs in C++ programs. In D all variables and members are initialized by default. If that happens to be expensive, the <code class="prettyprint">= void</code> initialization can be used instead.
</p>
<h2> DUB</h2>
<p>D has a package manager. C++ has none that is popular in its community.<br>Therefore, using a <a href="http://code.dlang.org/">third-party library</a> is many times easier.
</p>
<h2> No more implicit conversion of arrays to pointers</h2>
<p>It didn't make much sense even in C.
</p>
<h2> Ranges simpler to implement than iterators</h2>
<p>Ever implemented a C++ iterator? It can be a bit tricky.
</p>
<h2> Move and copy semantics radically simplified</h2>
<p>D makes the assumption that structs and classes are copyable by bit copy. It adds some restrictions on internal pointers, but overall it's simpler.
</p>
<h2> <code class="prettyprint">unittest</code> blocks</h2>
<p>Built-in unit-tests lower the barrier for testing.
</p>
<h2> Documentation comments</h2>
<p>Built-in documentation comments avoid the need for an external tool that inevitably nobody uses.
</p>
<h2> The D STL is actually readable</h2>
<p>C++'s STL are somewhat readable, but less so.
</p>
<h2> No more diamond inheritance</h2>
<p>C++ having multiple inheritance implies a <a href="http://www.amazon.fr/Inside-Object-Model-Stanley-Lippman/dp/0201834545">complex object model</a>.<br>With <code class="prettyprint">alias this</code>, multiple implementation inheritance is pretty much never needed.
</p>
<h2> Saner operator overloading</h2>
<p>Making custom numerical types requires a lot less operator overloads.
</p>
<h2> ++pre and post-increment++ have been fixed</h2>
<p>See how <a href="#Should-I-use-++pre-increment-or-post-increment++?">here</a>.
</p>
<h2> GC</h2>
<p>For the large majority of programs, the GC is a productivity enhancer. For the other programs, it's <a href="#How-the-D-Garbage-Collector-works">not that bad</a>.
</p>
<h2> No need for C++ template's heroes</h2>
<p>The easier and more powerful templates in D allow the <em>average</em> programmer to create meta-programs routinely. Not just one programmer in your team which happen to be comfortable with them.
</p>
<p>&nbsp;
</p>
<h2> Downsides</h2>
<p>For balance, here are the downsides <strong>(opinionated again)</strong>:
</p>
<ul>
<li>D has a way smaller (growing) community.
</li>
<li>C++ has nice, composable RAII. D has a more complicated <a href="#The-trouble-with-class-destructors">story</a> with resources.
</li>
<li>D is easy to start using but not that easy to use really well. Hence, this website.
</li>
<li>Not every purpose is compatible with a GC.
</li>
</ul>
</div><a name="How-the-D-Garbage-Collector-works"></a><div class="idiom"><a class="permalink" href="#How-the-D-Garbage-Collector-works">Link
</a><h1>How the D Garbage Collector works</h1>
<p>There seems to be a stigma surrounding Garbage Collection when you talk to C++ users. The GC would be an wild memory-hungry beast that can't be tamed, essentially outside the control of the programmer. It would render real-time work <a href="#The-impossible-real-time-thread">impossible</a> by its mere presence.
</p>
<p>But the D Garbage Collector is firmly under the application control. Once you learn how it works, it doesn't seem so uncontrollable, and reveal itself as what it really is: a <a href="http://dlang.org/garbage.html">trade-off</a> that most modern languages have choosen.
</p>
<h2> How the D GC works:</h2>
<p>First of all, collections are <strong>not triggered randomly</strong> but when a thread allocates memory.
</p>
<ul>
<li>A thread tries to allocate memory. At this point the GC may decide to collect garbage. If so, the current thread is <em>hijacked</em> for GC work.
</li>
<li>Memory ranges, starting from <em>roots</em>, are scanned recursively looking for more pointers into GC-owned memory. Each memory regions use markers to avoid scanning the same block of memory multiple times. <strong>This step can be slow.</strong> The GC features optimizations to speed-up scanning: heap areas are labelled with types, only areas with pointers are scanned, and pointer tp GC memory have <a href="http://dlang.org/garbage.html">restrictions</a>.
</li>
<li>GC allocated memory that has no active pointers to it and do not need destructors to run is freed.
</li>
<li>Conversely, all unreachable memory that needs destructors to run is queued.
</li>
<li>All threads are resumed. The GC pause is then finished.
</li>
<li>Destructors for all queued memory are run. Unfortunately there is <a href="#The-trouble-with-class-destructors">caveats</a> associated with the GC thread calling destructors.
</li>
<li>Remaining unreachable memory is freed.
</li>
<li>The current thread returns to whatever work it was doing.
</li>
</ul>
<h2> Tips</h2>
<p>Intuitively, one can see that memory scanning is a potentially long and expensive process. Keeping a small GC heap makes it faster.<br>What you can do to accelerate scanning is using <code class="prettyprint">malloc</code>/<code class="prettyprint">free</code> instead of <code class="prettyprint">new</code> to allocate big chunks of memory.<br>Anything that reduces the total amount of GC-owned memory will reduce the maximum pause duration.
</p>
<h2> More about the GC</h2>
<p>See: <a href="http://dlang.org/garbage.html">http://dlang.org/garbage.html</a>.
</p>
</div><a name="if-(__ctfe)"></a><div class="idiom"><a class="permalink" href="#if-(__ctfe)">Link
</a><h1><code class="prettyprint">if (__ctfe)</code></h1>
<p>D will run a lot of things through Compile-Time Function Execution (CTFE) if you ask for it.<br>Sometimes it is useful to branch based on whether the function is executing at compile-time or runtime.
</p>
<p>That's what <code class="prettyprint">__ctfe</code> is for.
</p>
<pre class="prettyprint"><code>import std.stdio;

string AmIInCTFE()
{
    if (__ctfe)
        return "Hello from CTFE!";
    else
        return "Hello from runtime!";
}

void main(string[] args)
{
    writefln(AmIInCTFE());
    pragma(msg, AmIInCTFE());
}
</code></pre></div><a name="if-embedded-declaration"></a><div class="idiom"><a class="permalink" href="#if-embedded-declaration">Link
</a><h1><code class="prettyprint">if</code> embedded declaration</h1>
<p>It's legal to declare a variable inside an <code class="prettyprint">if</code> condition.
</p>
<pre class="prettyprint"><code>// AA lookup shortcut
if (auto found = key in AA)
{
    // found only defined in this scope
    doStuff(*found);
}
</code></pre><p>The branch is taken if the right expression evaluates to a truthy value.
</p>
<pre class="prettyprint"><code>// Equivalent for Java's instanceof
if (auto derived = cast(Derived)obj)
{
    // derived only defined in this scope
    doStuff(derived);
}
</code></pre></div><a name="Implicit-conversion-for-user-defined-types"></a><div class="idiom"><a class="permalink" href="#Implicit-conversion-for-user-defined-types">Link
</a><h1>Implicit conversion for user-defined types</h1>
<p>D officially forbid implicit conversions for user-defined types to avoid the pitfalls associated with them.<br>But defining an implicit conversion is actually possible by abusing <code class="prettyprint">alias this</code>.
</p>
<pre class="prettyprint"><code>import std.stdio;

struct NumberAsString
{
    private string value;
    this(string value)
    {
        this.value = value;
    }

    int convHelper()
    {
        return to!int(value);
    }
    alias convHelper this;
}

void main(string[] args)
{
    auto a = NumberAsString("123");
    int b = a; // implicit conversion happening here
    writefln("%d", b);
}

</code></pre><p>This idiom was discovered by <a href="http://3d.benjamin-thaut.de/?p=90">Benjamin Thaut</a>.
</p>
</div><a name="Inheriting-from-Exception"></a><div class="idiom"><a class="permalink" href="#Inheriting-from-Exception">Link
</a><h1>Inheriting from Exception</h1>
<p>When in doubt, do it like Phobos!
</p>
<pre class="prettyprint"><code>class MyOwnException : Exception
{
    public
    {
        @safe pure nothrow this(string message,
                                string file =__FILE__,
                                size_t line = __LINE__,
                                Throwable next = null)
        {
            super(message, file, line, next);
        }
    }
}
</code></pre></div><a name="Linking-with-C-gotchas"></a><div class="idiom"><a class="permalink" href="#Linking-with-C-gotchas">Link
</a><h1>Linking with C gotchas</h1>
<h2> The little known <code class="prettyprint">pragma(mangle)</code></h2>
<p><code class="prettyprint">pragma(mangle)</code> is extremely useful when you need to statically link with a C function whose name is a reserved D keyword:
</p>
<pre class="prettyprint"><code>pragma(mangle, "version") extern(C) void c_version();
</code></pre></div><a name="Minimum-or-maximum-of-numbers"></a><div class="idiom"><a class="permalink" href="#Minimum-or-maximum-of-numbers">Link
</a><h1>Minimum or maximum of numbers</h1>
<p><code class="prettyprint">min</code> and <code class="prettyprint">max</code> are found in <code class="prettyprint">std.algorithm</code>, not <code class="prettyprint">std.math</code>.
</p>
<pre class="prettyprint"><code>import std.algorithm : max;
int a = -5;
int b = 4;
double c = 10.0;
double max_abc = max(a, b, c);
assert(max_abc == 10.0);
</code></pre><p>They work with builtin types and any number of arguments.
</p>
<p>See: <a href="http://dlang.org/phobos/std_algorithm.html#.min">http://dlang.org/phobos/std_algorithm.html#.min</a>
</p>
</div><a name="Never-use-&gt;=-for-dependencies"></a><div class="idiom"><a class="permalink" href="#Never-use-&gt;=-for-dependencies">Link
</a><h1>Never use &gt;= for dependencies</h1>
<p>Using DUB and dependencies? Here is a pattern you should avoid:
</p>
<pre class="prettyprint"><code>{
    "name": "my-program",

    "dependencies":
    {
        "awesome-lib": "&gt;=1.0.0"
    }
}


</code></pre><p>Depending on a library using <code class="prettyprint">&gt;=</code> is risky. If <code class="prettyprint">awesome-lib</code> breaks its API then releases a new major tag, your project will break. This is implicit in SemVer and using <code class="prettyprint">&gt;=</code> suscribes for immediate breakage.
</p>
<p>Now this can be useful for executables, but this is especially bad for publicly released libraries. Any downstream project might break in the future when using your already released tags. And <em>how will you fix tags that are already in use?</em>
</p>
<p><strong>TL;DR Do not depend on APIs that will break in the future. Use `~&gt;` or `==` instead.</strong>
</p>
<p>See: <a href="http://code.dlang.org/package-format#version-specs">http://code.dlang.org/package-format#version-specs</a>
</p>
</div><a name="Optimal-AA-lookup"></a><div class="idiom"><a class="permalink" href="#Optimal-AA-lookup">Link
</a><h1>Optimal AA lookup</h1>
<p>When used on an Associative Array, the <code class="prettyprint">in</code> operator returns a pointer to the searched element, or <code class="prettyprint">null</code> if not found.
</p>
<p>Instead of:
</p>
<pre class="prettyprint"><code>key in aa ? aa[key] : ValueType.init;
</code></pre><p>which perform 2 AA lookups prefer:
</p>
<pre class="prettyprint"><code>auto ptr = key in aa;
ptr ? *ptr : ValueType.init;
</code></pre><p>The <code class="prettyprint">.get</code> builtin property can also be used. It provides a default value when the key doesn't exist.
</p>
<pre class="prettyprint"><code>aa.get(key, defaultValue);
</code></pre></div><a name="Patching-a-library-available-on-the-DUB-registry"></a><div class="idiom"><a class="permalink" href="#Patching-a-library-available-on-the-DUB-registry">Link
</a><h1>Patching a library available on the DUB registry</h1>
<p>How to patch a <a href="http://code.dlang.org/">DUB</a> library with minimal hassle for users?
</p>
<ol>
<li>Commit your hopefully working fix.
</li>
<li>Test it. <code class="prettyprint">dub add-local</code> or <code class="prettyprint">dub test</code> can help to do it.
</li>
<li>Make a git tag. <strong>Please try to respect</strong> <a href="http://semver.org/">SemVer</a> with respect to breaking changes, else you could break an unknown number of already released software. Also don't name your tag <code class="prettyprint">1.0.0</code> instead of <code class="prettyprint">v1.0.0</code>, else the registry won't take it.
</li>
<li>Push the changes online. I would advise <code class="prettyprint">git push</code> then <code class="prettyprint">git push --tags</code> but to be honest I don't really know why it's better in this order. At this point the fix is online. This is not finished yet!
</li>
<li>Login on <a href="http://code.dlang.org">http://code.dlang.org</a> and click on <code class="prettyprint">Trigger manual update</code> button. This will acknowledge the new version and allow downstream to update to the new tag as soon as possible. <strong>Do not skip this step if you want a timely fix.</strong>
</li>
<li>If downstream doesn't actually download the latest tag, consider using <code class="prettyprint">dub clean-caches</code> to update the list of available packages.
</li>
<li>Your users are now delighted. Enjoy the endorphin rush.
</li>
</ol>
</div><a name="Phobos-gems"></a><div class="idiom"><a class="permalink" href="#Phobos-gems">Link
</a><h1>Phobos Gems</h1>
<h2> Check recoverable errors with <code class="prettyprint">std.exception.enforce</code></h2>
<p>It is good practice to check for unrecoverable errors with <code class="prettyprint">assert</code>, and recoverable errors with <code class="prettyprint">enforce</code>.<br>Which means you should <a href="#Unrecoverable-vs-recoverable-errors">learn the difference</a> between those two types of errors.
</p>
<p>See: <a href="http://dlang.org/phobos/std_exception.html#.enforce">http://dlang.org/phobos/std_exception.html#.enforce</a>
</p>
<h2> Allocate a class object on stack with <code class="prettyprint">std.typecons.scoped</code></h2>
<p><code class="prettyprint">scoped</code> replaces <code class="prettyprint">new</code> and put a <code class="prettyprint">class</code> object on the stack, with the double benefit of avoiding GC and performing deterministic destruction.
</p>
<pre class="prettyprint"><code>import std.typecons;
auto myClass = scoped!MyClass(); // no need for 'new', and automatic destructor call at scope exit.
</code></pre><p>See: <a href="http://dlang.org/phobos/std_typecons.html#.scoped">http://dlang.org/phobos/std_typecons.html#.scoped</a>
</p>
<h2> Remove type qualifiers with <code class="prettyprint">std.traits.Unqual</code></h2>
<p><code class="prettyprint">Unqual</code> enables to write template and instantiate them with <code class="prettyprint">const(T)</code>, <code class="prettyprint">immutable(T)</code>, <code class="prettyprint">shared(T)</code>&hellip;
</p>
<p>See: <a href="http://dlang.org/phobos/std_traits.html#.Unqual">http://dlang.org/phobos/std_traits.html#.Unqual</a>
</p>
<h2> Convert a range to a dynamic array with <code class="prettyprint">std.array.array</code></h2>
<p><code class="prettyprint">array</code> is usually used to convert a range computation to a dynamic array.
</p>
<p>See: <a href="http://dlang.org/phobos/std_array.html#.array">http://dlang.org/phobos/std_array.html#.array</a>
</p>
</div><a name="Placement-new-with-emplace"></a><div class="idiom"><a class="permalink" href="#Placement-new-with-emplace">Link
</a><h1>Placement new with <code class="prettyprint">emplace</code></h1>
<p>C++ has <a href="http://www.drdobbs.com/cpp/calling-constructors-with-placement-new/232901023">"placement new"</a> which is a language construct to construct an object at a given pointer location.
</p>
<p>The D equivalent is a Phobos function called <code class="prettyprint">std.conv.emplace</code> (documentation <a href="http://dlang.org/phobos/std_conv.html#.emplace">here</a>).
</p>
<p><code class="prettyprint">emplace</code> can be used as an alternative to <code class="prettyprint">new</code> to support custom allocation. For example this perform construction of a class instance on the stack.
</p>
<pre class="prettyprint"><code>import std.conv : emplace;
ubyte[__traits(classInstanceSize, YourClass)] buffer;
YourClass obj = emplace!YourClass(buffer[], ctor args...);
// Destroy the object explicitly at scope exit, which will
// call the destructor deterministically.
scope(exit) .destroy(obj);
</code></pre><p>Courtesy of <a href="http://arsdnet.net/">Adam D. Ruppe</a>.
</p>
</div><a name="Porting-from-C-gotchas"></a><div class="idiom"><a class="permalink" href="#Porting-from-C-gotchas">Link
</a><h1>Porting from C gotchas</h1>
<h2> Globals must be marked <code class="prettyprint">__gshared</code></h2>
<p>Variables at global scope are in Thread Local Storage (TLS) unless qualified with <code class="prettyprint">shared</code> or <code class="prettyprint">__gshared</code>. You are <a href="#The-truth-about-shared">probably</a> wanting to use <code class="prettyprint">__gshared</code>.
</p>
<pre class="prettyprint"><code>// A C global variable
int my_global_var;
</code></pre><pre class="prettyprint"><code>// Equivalent D global
__gshared int myGlobalVar;
</code></pre><h2> <code class="prettyprint">long</code> and <code class="prettyprint">unsigned long</code></h2>
<p>C's <code class="prettyprint">long</code> and <code class="prettyprint">unsigned long</code> have variable size, no builtin type is equivalent in D!
</p>
<p>The recommended way is to use <code class="prettyprint">c_long</code> and <code class="prettyprint">c_ulong</code> from module <code class="prettyprint">core.stdc.config</code>.
</p>
<pre class="prettyprint"><code>// A C function declaration
unsigned long countBeans(const long* n)
</code></pre><pre class="prettyprint"><code>// Equivalent D function declaration
import core.stdc.config;
c_ulong countBeans(const(c_long)* n);
</code></pre><p><code class="prettyprint">c_int</code> and <code class="prettyprint">c_uint</code> also exist to replace <code class="prettyprint">int</code> and <code class="prettyprint">unsigned int</code>, but because they are 32-bits in most architectures, it's usually simply translated with D's <code class="prettyprint">int</code> and <code class="prettyprint">uint</code> instead.
</p>
<h2> Multi-dimensional arrays declarations</h2>
<pre class="prettyprint"><code>// A C array declaration
int myMatrix[4][2] = { { 1, 2}, { 3, 4}, { 5, 6}, { 7, 8} };
</code></pre><pre class="prettyprint"><code>// Equivalent D array declaration
int[2][4] myMatrix = [ [ 1, 2], [ 3, 4], [ 5, 6], [ 7, 8] ];
</code></pre><h2> Enum values without enum namespace</h2>
<pre class="prettyprint"><code>// A C enum declaration
typedef enum
{
    STRATEGY_RANDOM,
    STRATEGY_IMMEDIATE,
    STRATEGY_SEARCH
} strategy_t;
</code></pre><pre class="prettyprint"><code>// Equivalent D enum declaration
alias strategy_t = int;
enum : strategy_t
{
    STRATEGY_RANDOM,
    STRATEGY_IMMEDIATE,
    STRATEGY_SEARCH
}
</code></pre><p>This avoids having to write <code class="prettyprint">strategy_t.STRATEGY_IMMEDIATE</code> instead of <code class="prettyprint">STRATEGY_IMMEDIATE</code> when porting C code.
</p>
<h2> Anonymous <code class="prettyprint">struct</code> and <code class="prettyprint">union</code></h2>
<p>D provides a limited form of anonymous nested <code class="prettyprint">struct</code> and <code class="prettyprint">union</code>, but they can't be used to translate this C anonymous struct:
</p>
<pre class="prettyprint"><code>// A C anonymous struct
struct Foo
{
    struct
    {
        int x;
    } bar;
};
</code></pre><pre class="prettyprint"><code>// Equivalent D
struct Foo
{
    private struct bar_t
    {
        int x;
    }
    bar_t bar;
}
</code></pre><h2> Convert array to pointers explicitely</h2>
<p>When porting from C you will probably have to spam <code class="prettyprint">.ptr</code> anywhere an array is implicitely converted to a pointer.
</p>
<pre class="prettyprint"><code>// In C
void sum(const int *array, int n);
int coeff[16];
sum(coeff, sizeof(coeff) / sizeof(int));
</code></pre><pre class="prettyprint"><code>// In D
void sum(const(int)* array, int n);
int[16] coeff;
sum(coeff.ptr, coeff.sizeof / int.sizeof); // array not implicitely convertible to a pointer
</code></pre></div><a name="Qualified-switch-using-with"></a><div class="idiom"><a class="permalink" href="#Qualified-switch-using-with">Link
</a><h1>Qualified switch using "with"</h1>
<p>Let's say we have an enum:
</p>
<pre class="prettyprint"><code>enum MyEnum
{
    small,
    normal,
    huge
}
</code></pre><p>Switching on an enum value is annoying and redundant: <code class="prettyprint">MyEnum</code> has to be repeated for each case.
</p>
<pre class="prettyprint"><code>final switch(enumValue)
{
case MyEnum.small:
    writeln("small");
    break;
case MyEnum.normal:
    writeln("normal");
    break;
case MyEnum.huge:
    writeln("huge");
    break;
}
</code></pre><p>We can work-around this by using <code class="prettyprint">with</code>:
</p>
<pre class="prettyprint"><code>final switch(enumValue) with (MyEnum)
{
case small:
    writeln("small");
    break;
case normal:
    writeln("normal");
    break;
case huge:
    writeln("huge");
    break;
}
</code></pre><p>This idiom was discovered by <a href="https://github.com/deadalnix">deadalnix</a>.
</p>
</div><a name="Recursive-Sum-Type-with-matching"></a><div class="idiom"><a class="permalink" href="#Recursive-Sum-Type-with-matching">Link
</a><h1>Recursive Sum Type with matching</h1>
<p>Never write a tagged union by hand again! <code class="prettyprint">std.variant.Algebraic</code> solves this nicely.
</p>
<p><strong>Recursive data-types are supported</strong> despite the documentation saying it's not.
</p>
<pre class="prettyprint"><code>import std.variant, std.typecons;
alias Symbol = Typedef!string;

// an Atom is either:
// - a string,
// - a double,
// - a bool,
// - a Symbol,
// - or Atom[]
alias Atom = Algebraic!(string, double, bool, Symbol, This[]); // Use 'This' for recursive ADT

Atom atom;
if (bool* b = atom.peek!bool()) // is atom a bool?
{
    // here *b is a bool
}

</code></pre><p><code class="prettyprint">Algebraic</code> can be used with the <a href="http://dlang.org/phobos/std_variant.html#.visit"><code class="prettyprint">visit</code></a> function to do an exhaustive match.
</p>
<pre class="prettyprint"><code>// an exhaustive match with this ADT
string toString(Atom atom)
{
    return atom.visit!(
        (Symbol sym) =&gt; cast(string)sym,
        (string s) =&gt; s,
        (double x) =&gt; to!string(x),
        (bool b) =&gt; (b ? "#t" : "#f"),
        (Atom[] atoms) =&gt; "(" ~ map!toString(atoms).joiner(" ").array.to!string ~ ")"
    );
}
</code></pre><p>See: <a href="http://dlang.org/phobos/std_variant.html#.Algebraic">http://dlang.org/phobos/std_variant.html#.Algebraic</a>
</p>
</div><a name="Searching-for-a-substring-position"></a><div class="idiom"><a class="permalink" href="#Searching-for-a-substring-position">Link
</a><h1>Searching for a substring position</h1>
<p>The <code class="prettyprint">indexOf</code> function in <code class="prettyprint">std.string</code> gives back the index of the first found substring or -1 if missing.
</p>
<pre class="prettyprint"><code>import std.string;
assert(indexOf("Hello home sweet home", "home") == 6);
</code></pre><p>See: <a href="http://dlang.org/phobos/std_string.html#.indexOf">http://dlang.org/phobos/std_string.html#.indexOf</a>
</p>
</div><a name="Should-I-use-++pre-increment-or-post-increment++&#x3F;"></a><div class="idiom"><a class="permalink" href="#Should-I-use-++pre-increment-or-post-increment++&#x3F;">Link
</a><h1>Should I use ++pre-increment or post-increment++?</h1>
<p>Either one. It did matter a bit in C++ but doesn't in D. The compiler rewrites internally post-increments to pre-increments if the expression result is unused.
</p>
<pre class="prettyprint"><code>  it++; // lowered to ++it since the result isn't used
  it--; // ditto, lowered to --it
</code></pre><p>Contrarily to <a href="http://en.cppreference.com/w/cpp/language/operator_incdec">C++</a>, a single operator overload is used to define both pre-increment and post-increment in user-defined types.
</p>
<pre class="prettyprint"><code>struct WrappedInt
{
    int m;

    // overload both ++pre and post++
    int opUnary(string op)() if (op == "++")
    {
        return ++m;
    }
}
</code></pre></div><a name="Skip-initialization-with-=-void"></a><div class="idiom"><a class="permalink" href="#Skip-initialization-with-=-void">Link
</a><h1>Skip initialization with <code class="prettyprint">= void</code></h1>
<p>In D, everything is initialized by default.<br>Because it may have a runtime cost, the syntax <code class="prettyprint">= void</code> allows to skip default assignment for stack variables.
</p>
<pre class="prettyprint"><code>void bark()
{
    int dog = void; // dog contains garbage
    if(cond)
        dog = 1;
    else
        dog = 2;
}
</code></pre><p><code class="prettyprint">= void</code> is also accepted for <code class="prettyprint">struct</code> or <code class="prettyprint">class</code> members but doesn't do anything useful at the moment. Don't use it there.
</p>
</div><a name="Slices-.capacity,-the-mysterious-property"></a><div class="idiom"><a class="permalink" href="#Slices-.capacity,-the-mysterious-property">Link
</a><h1>Slices <code class="prettyprint">.capacity</code>, the mysterious property</h1>
<p>Dynamic arrays aka slices in D have a <code class="prettyprint">.capacity</code> property: the maximum length the slice can reach before needing reallocation.
</p>
<pre class="prettyprint"><code>int[] arr = new int[10];
writeln(arr.capacity);
assert(arr.capacity &gt;= arr.length);
</code></pre><p>Since <code class="prettyprint">.capacity</code> is read-only, the <code class="prettyprint">.reserve</code> builtin property also exist to ensure allocation size. This is similar to C++'s <code class="prettyprint">std::vector::capacity()</code> and <code class="prettyprint">std::vector::reserve(size_t n)</code>. Handy!
</p>
<pre class="prettyprint"><code>T[] arr;
arr.reserve(N);
foreach(i ; 0..N)
  arr ~= expr(i);                        // guaranteed not to allocate in the loop
</code></pre><p>I hear you saying: <strong>"How is that possible since D slices are only a pointer and a length?"</strong><br>There is a trick, getting that information relies on the GC, and slices pointing to non-GC memory will report a capacity of 0 which means reallocating is mandatory for appending.
</p>
<pre class="prettyprint"><code>char[16] hexChars = "0123456789abcdef";
char[] decChars = hexChars[0..10];
writeln(decChars.capacity);              // output '0' since decChars points to non-GC memory

decChars = decChars.dup;                 // makes a GC copy of the slice
writeln(decChars.capacity);              // outputs non-zero value now that decChars points to GC memory
</code></pre></div><a name="Smallest-dub.json-for-an-executable"></a><div class="idiom"><a class="permalink" href="#Smallest-dub.json-for-an-executable">Link
</a><h1>Smallest dub.json for an executable</h1>
<p>What DUB options are strictly necessary in a <code class="prettyprint">dub.json</code> file to build an executable?
</p>
<p>It turns out only one is needed:
</p>
<pre class="prettyprint"><code>{
    "name": "program_name"
}
</code></pre><p>Place the source code in a <code class="prettyprint">source/main.d</code> file and DUB will find it and guess<br>you want to build an executable.
</p>
<p>No <code class="prettyprint">main.d</code>? It will guess it's a source library then.
</p>
</div><a name="So-what-does--release-do,-exactly&#63;"></a><div class="idiom"><a class="permalink" href="#So-what-does--release-do,-exactly&#63;">Link
</a><h1>So what does <code class="prettyprint">-release</code> do, exactly?</h1>
<p>In the DMD compiler, the <code class="prettyprint">-release</code> switch does the following things:
</p>
<ul>
<li>Removing contracts (<code class="prettyprint">in</code> and <code class="prettyprint">out</code> blocks).
</li>
<li>Removing bounds checking in all but <code class="prettyprint">@safe</code> code. That means: <code class="prettyprint">@trusted</code>, <code class="prettyprint">@system</code>, and unmarked functions won't have bounds checks. To overide this behaviour, use the <code class="prettyprint">-boundscheck</code> switch.
</li>
<li>Removing assertions, except <code class="prettyprint">assert(false)</code> which is <a href="#assert(false)-is-special">special</a>.<br><strong>Failed assertions are considered Undefined Behaviour.</strong> The optimizer can assume that a removed assertion always holds and use this fact for optimization.
</li>
</ul>
<p>See: <a href="http://dlang.org/dmd-windows.html#switch-release">http://dlang.org/dmd-windows.html#switch-release</a>
</p>
</div><a name="Static-arrays-are-value-types"></a><div class="idiom"><a class="permalink" href="#Static-arrays-are-value-types">Link
</a><h1>Static arrays are value types</h1>
<p>It's important to note that static arrays in D are value types.
</p>
<pre class="prettyprint"><code>void addFour(int[16] arr) // The whole of arr is passed on the stack.
{
    arr[] += 4;           // Only the local version is modified.
}
int[16] a;
addFour(a);               // a passed by value on the stack, not by pointer.
</code></pre><p>That makes such declaration a trap when porting functions from C or C++.
</p>
<p>To pass static arrays by reference, either write a function taking a slice or use ref.
</p>
<pre class="prettyprint"><code>void addFive(ref int[16] arr)
{
    arr[] += 5;         // Caller parameter modified.
}
void addSix(int[] arr)
{
    arr[] += 6;         // Caller parameter modified.
}
int[16] a;
addFive(a);
addSix(a);              // Static arrays implicitely convertible to slices.
</code></pre></div><a name="The-impossible-real-time-thread"></a><div class="idiom"><a class="permalink" href="#The-impossible-real-time-thread">Link
</a><h1>Real-time thread</h1>
<p>It is often said on Internet forums that D couldn't possibly do real-time work, since <em>its stop-the-world GC might pause every thread at once</em>.
</p>
<p><strong>This is wildly inaccurate.</strong> The GC pauses all threads <em>that have been registered</em>.
</p>
<p>Real-time threads like audio callbacks are doable since forever. Here is how:
</p>
<ul>
<li><p>Use a thread that isn't registered. Such a thread could be created by an external library, or with <code class="prettyprint">core.thread.Thread</code> and then <a href="http://dlang.org/phobos/core_thread.html#.thread_detachThis">unregistered</a>.
</p>
</li>
<li><p>Make the thread function <code class="prettyprint">@nogc</code>. You can't use the GC from an unregistered thread.
</p>
</li>
</ul>
<p><strong>Another limitation:</strong> Such a thread must not hold roots to GC objects. What it means is that you can use GC objects from the real-time thread, but these GC objects should be pointed to by other threads to avoid them being collected.
</p>
</div><a name="The-trouble-with-class-destructors"></a><div class="idiom"><a class="permalink" href="#The-trouble-with-class-destructors">Link
</a><h1>The trouble with class destructors</h1>
<p>Despite having a GC, resource management in D is one of the most difficult point of the language. 
</p>
<p>In particular, class destructors in D enjoy a variety of limitations you should be aware of.
</p>
<h2> 1. Don't expect class destructors to be called at all by the GC</h2>
<p>The garbage collector is not guaranteed to run the destructors for all unreferenced objects.
</p>
<h2> 2. Don't expect class destructors to be called timely and by the right thread</h2>
<p>Class destructors might be called <strong>when a collect is performed</strong> which can be later than you wished and by <strong>any thread</strong> the GC is currently running on.
</p>
<h2> 3. Don't expect members to be valid in a class destructor</h2>
<p>The order in which the garbage collector calls destructors for unreferenced objects is <em>not specified</em>. <strong>Don't use members in class destructors if you expect to be called by the GC.</strong>
</p>
<h2> 4. Don't allocate within a destructor called by the GC</h2>
<p>Using GC allocation is forbidden within a class destructor.
</p>
<h2> Conclusion</h2>
<p>All this is in sharp contrast with the deterministic way C++ deals with destructors. However, all these constraints go away if destructors are called manually using:
</p>
<ul>
<li><code class="prettyprint">std.typecons.scoped</code> (documentation <a href="http://dlang.org/phobos/std_typecons.html#.scoped">here</a>)
</li>
<li><code class="prettyprint">std.typecons.Unique</code> (documentation <a href="http://dlang.org/phobos/std_typecons.html#.Unique">here</a>)
</li>
<li>calling <a href="http://dlang.org/phobos/object.html#.destroy"><code class="prettyprint">destroy</code></a> on an object manually
</li>
<li>using <code class="prettyprint">delete</code> or <code class="prettyprint">scope class</code> (deprecated)
</li>
</ul>
<p><strong>TL;DR There is not much that can safely be done in a class destructor if called by the GC. Either call all of them deterministically or don't do anything in destructors. </strong>
</p>
<p>See: <a href="http://dlang.org/class.html">http://dlang.org/class.html</a>
</p>
</div><a name="The-truth-about-shared"></a><div class="idiom"><a class="permalink" href="#The-truth-about-shared">Link
</a><h1>The truth about shared</h1>
<p>It's unclear when and how <code class="prettyprint">shared</code> will be implemented.
</p>
<p>Virtually noone use <code class="prettyprint">shared</code> currently. You are better off ignoring it at this moment.
</p>
</div><a name="Unrecoverable-vs-recoverable-errors"></a><div class="idiom"><a class="permalink" href="#Unrecoverable-vs-recoverable-errors">Link
</a><h1>Unrecoverable vs recoverable errors</h1>
<p><em>This item is language-agnostic and perhaps the most widely applicable tip on this page.</em>
</p>
<h2> Simply said</h2>
<p>Being a D programmer requires knowing the <strong>two fundamental types of errors</strong> in programs.
</p>
<p>Similarly to many languages with exceptions, errors are separated in <strong>logic errors</strong> and <strong>runtime errors</strong>. This is embodied in the two-headed exception hierarchy:
</p>
<ul>
<li>the <code class="prettyprint">Error</code> class is for <em>logic errors</em> also known as <em>unrecoverable errors</em> also known as&hellip; <em>bugs</em>
</li>
<li>the <code class="prettyprint">Exception</code> class is for <em>runtime errors</em> also known as <em>recoverable errors</em> also known as <em>input errors</em>. But it can also be used for hard-to-classify errors.
</li>
</ul>
<h2> Unrecoverable/logic errors</h2>
<p>Such errors are basically <strong>bugs</strong>. Logic errors includes but are not limited to:
</p>
<ul>
<li>divide by zero
</li>
<li>out-of-bounds access
</li>
<li>null dereferences
</li>
<li>invalid floating point operations like <code class="prettyprint">log(-1)</code> or <code class="prettyprint">arccos(2)</code>
</li>
<li>out of memory
</li>
<li>failed contract
</li>
</ul>
<p>The recommended way to deal with these is to throw an <code class="prettyprint">Error</code>, for example by using <code class="prettyprint">assert</code>. Indeed <strong>the only reasonable option when encountering a logic error is to crash.</strong> This is how highly reliable system are built: let the OS handle the program crash, let a supervisor restart the faulty process.
</p>
<p>If you think you should recover from bugs and keep things running anyway, <strong>you are dangerous</strong>.
</p>
<h2> Recoverable/input errors</h2>
<p>Such errors are basically <strong>not bugs</strong>:
</p>
<ul>
<li>all kinds of errors with invalid input
</li>
<li>all kinds of I/O failure (eg: failure to read a file)
</li>
<li>failed API calls
</li>
</ul>
<p>The canonical way to deal with these is to throw an <code class="prettyprint">Exception</code>, for example by using <a href="#Phobos-gems"><code class="prettyprint">enforce</code></a>.
</p>
<p>Some errors are difficult to classify: what is unrecoverable for a program part might well be recoverable for another. In this case it is recommended to use <code class="prettyprint">Exception</code>.
</p>
<h2> More material</h2>
<p>Walter Bright repeatedly explained this item in the D newsgroup:
</p>
<p><em>I believe this is a misunderstanding of what exceptions are for. "File not found" exceptions, and other errors detected in inputs, are routine and routinely recoverable.</em>
</p>
<p><em>This discussion has come up repeatedly in the last 30 years. It's root is always the same - conflating handling of input errors, and handling of bugs in the logic of the program.</em>
</p>
<p><em>The two are COMPLETELY different and dealing with them follow completely different philosophies, goals, and strategies.</em>
</p>
<p><em>Input errors are not bugs, and vice versa. There is no overlap.</em>
</p>
<p>See also: <a href="http://forum.dlang.org/post/m07gf1$18jl$1@digitalmars.com">http://forum.dlang.org/post/m07gf1$18jl$1@digitalmars.com</a>
</p>
</div><a name="Using-a-struct-to-simplify-format()"></a><div class="idiom"><a class="permalink" href="#Using-a-struct-to-simplify-format()">Link
</a><h1>Using a struct to simplify format()</h1>
<p>When using <strong>std.conv.to()</strong> or <strong>std.stdio.write()</strong>, the arguments are formated using a predefined format.
</p>
<p>Structs are processed differently. By default, all the members of a <strong>struct</strong> are converted <br>but the internal <strong>to()</strong> also checks if a <strong>struct</strong> implements a custom <strong>toString()</strong> function. <br>If so, this function is used and the default formatting of the members doesn't happen.
</p>
<p>This can be used as a trick to override the default predefined formats of a basic type.
</p>
<p>For example, to display a pointer, with all the hex digits, a prefix and this whatever is the address size,<br>we define a <strong>struct</strong> with a single member of type <strong>void*</strong> and a custom <strong>toString()</strong> function:
</p>
<pre class="prettyprint"><code>import std.stdio;

struct FmtPtr
{
    void* ptr;
    string toString()
    {
        import std.format;
        static if (size_t.sizeof == 4)
            return format("0X%.8X ", cast(size_t)ptr);   
        static if (size_t.sizeof == 8)
            return format("0X%.16X ", cast(size_t)ptr);        
    }    
}

void main(string[] args)
{
    import core.stdc.stdlib;
    auto a = malloc(8);
    auto b = malloc(8);
    auto c = malloc(8);
    
    // ugly custom formatting
    writeln("0X", a, " ", "0X", b, " ", "0X", c);
    writefln("0X%.8X 0X%.8X 0X%.8X", a, b, c);
	
    // clean and clear equivalent using the struct
    writeln(FmtPtr(a), FmtPtr(b), FmtPtr(c));
}
</code></pre></div></div><a href="https://github.com/p0nce/d-idioms/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
<footer><h2>About
</h2><p>Hi, I'm a <a href="http://github.com/p0nce">software developer</a> currently building <a href="http://www.auburnsounds.com">real-time audio plugins for voice</a>. I hope this site has been useful!
</p><h2>Other contributors:
</h2><ul id="contributors"><li><a href="https://github.com/BBasile">Basile Burg
</a></li></ul></footer></body></html>